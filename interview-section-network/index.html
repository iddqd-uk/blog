<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Часто на интервью задают вопросы связанные не только с основным/дополнительным ЯП или СУБД, но и с тем, как приложения взаимодействуют между собой используя сетевую коммуникацию. Для понимания того, как эти шестерёнки вращаются и что нужно иметь в виду отвечая на вопросы из этой серии и была написана эта заметка.
"><title>Вопросы и ответы по сетям и протоколам</title>
<link rel=canonical href=https://blog.iddqd.uk/interview-section-network/>
<link rel=stylesheet href=https://blog.iddqd.uk/scss/style.min.471bdc6463fbad60208a71af0eed86d783b5cf8d4d274ae3d77e962c37962c18.css>
<meta property="og:title" content="Вопросы и ответы по сетям и протоколам">
<meta property="og:description" content="Часто на интервью задают вопросы связанные не только с основным/дополнительным ЯП или СУБД, но и с тем, как приложения взаимодействуют между собой используя сетевую коммуникацию. Для понимания того, как эти шестерёнки вращаются и что нужно иметь в виду отвечая на вопросы из этой серии и была написана эта заметка.
">
<meta property="og:url" content="https://blog.iddqd.uk/interview-section-network/">
<meta property="og:site_name" content="blog [dot] iddqd">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="network"><meta property="article:published_time" content="2022-02-14T12:37:08+00:00"><meta property="article:modified_time" content="2022-02-14T12:37:08+00:00"><meta property="og:image" content="https://blog.iddqd.uk/interview-section-network/cover.png">
<meta name=twitter:title content="Вопросы и ответы по сетям и протоколам">
<meta name=twitter:description content="Часто на интервью задают вопросы связанные не только с основным/дополнительным ЯП или СУБД, но и с тем, как приложения взаимодействуют между собой используя сетевую коммуникацию. Для понимания того, как эти шестерёнки вращаются и что нужно иметь в виду отвечая на вопросы из этой серии и была написана эта заметка.
"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.iddqd.uk/interview-section-network/cover.png">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1B4Z5Q844N"></script>
<script>var dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-1B4Z5Q844N',{anonymize_ip:!0})}</script>
<link rel=apple-touch-icon sizes=180x180 href="https://blog.iddqd.uk/apple-touch-icon.png?v=1746929313">
<link rel=icon type=image/png sizes=32x32 href="https://blog.iddqd.uk/favicon-32x32.png?v=1746929313">
<link rel=icon type=image/png sizes=16x16 href="https://blog.iddqd.uk/favicon-16x16.png?v=1746929313">
<link rel=manifest href=https://blog.iddqd.uk/webmanifest.json>
<meta name=msapplication-TileColor content="#303030">
<meta name=theme-color content="#303030">
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"dark")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Назад</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<div class=article-image>
<a href=/interview-section-network/>
<img src=/interview-section-network/cover_hu21de3eef183cf18e204d3e54b899aa35_31715_800x0_resize_box_3.png srcset="/interview-section-network/cover_hu21de3eef183cf18e204d3e54b899aa35_31715_800x0_resize_box_3.png 800w, /interview-section-network/cover_hu21de3eef183cf18e204d3e54b899aa35_31715_1600x0_resize_box_3.png 1600w" width=800 height=331 loading=lazy alt="Featured image of post Вопросы и ответы по сетям и протоколам">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/interview/ style=background-color:#0b2a4f;color:#fff>
Interview
</a>
</header>
<h2 class=article-title>
<a href=/interview-section-network/>Вопросы и ответы по сетям и протоколам</a></h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2022.02.14</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
Время чтения: 20 мин.
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<div class=outdated-post style=display:none data-posted-at=2022-02-14>
<strong>Внимание!</strong> Данный пост был опубликован более года назад и, возможно, уже утратил свою былую актуальность. Но это не точно.
</div>
<p>Часто на интервью задают вопросы связанные не только с основным/дополнительным ЯП или СУБД, но и с тем, как приложения взаимодействуют между собой используя сетевую коммуникацию. Для понимания того, как эти шестерёнки вращаются и что нужно иметь в виду отвечая на вопросы из этой серии и была написана эта заметка.</p>
<div class=toc>
<nav id=TableOfContents>
<ol>
<li><a href=#что-происходит-после-ввода-адреса-в-браузер>Что происходит после ввода адреса в браузер?</a>
<ol>
<li><a href=#dns>DNS</a></li>
<li><a href=#отправка-пакета>Отправка пакета</a></li>
<li><a href=#tls-handshake>TLS Handshake</a></li>
<li><a href=#http-запрос>HTTP запрос</a></li>
</ol>
</li>
<li><a href=#перечисли-все-уровни-модели-osi>Перечисли все уровни модели OSI?</a></li>
<li><a href=#что-такое-ip-адрес>Что такое IP адрес?</a></li>
<li><a href=#какие-режимы-передачи-данных-бывают>Какие режимы передачи данных бывают?</a></li>
<li><a href=#что-такое-nat>Что такое NAT?</a></li>
<li><a href=#расскажи-про-dhcp>Расскажи про DHCP?</a></li>
<li><a href=#что-такое-icmp>Что такое ICMP?</a></li>
<li><a href=#что-такое-tcpip>Что такое TCP/IP?</a>
<ol>
<li><a href=#ip-internet-protocol>IP (Internet Protocol)</a></li>
<li><a href=#tcp-transmission-control-protocol>TCP (Transmission Control Protocol)</a></li>
<li><a href=#udp-user-datagram-protocol>UDP (User Datagram Protocol)</a></li>
</ol>
</li>
<li><a href=#какие-бывают-версии-http>Какие бывают версии HTTP?</a>
<ol>
<li><a href=#http09><code>HTTP/0.9</code></a></li>
<li><a href=#http10><code>HTTP/1.0</code></a></li>
<li><a href=#http11><code>HTTP/1.1</code></a></li>
<li><a href=#http2><code>HTTP/2</code></a></li>
<li><a href=#http3><code>HTTP/3</code></a></li>
</ol>
</li>
<li><a href=#как-работает-https>Как работает HTTPS?</a>
<ol>
<li><a href=#ssl>SSL</a></li>
<li><a href=#tls>TLS</a></li>
<li><a href=#шифрование>Шифрование</a></li>
</ol>
</li>
</ol>
</nav>
</div>
<h2 id=что-происходит-после-ввода-адреса-в-браузер>Что происходит после ввода адреса в браузер?</h2>
<p>Адрес (по-другому URL), который был введён в строку адреса состоит из:</p>
<ul>
<li>Протокола, который используется для доступа к ресурсу (<code>http</code>, <code>https</code>, <code>ftp</code> и т.д.)
<ul>
<li>Если протокол введён не был, то браузер смотрит - есть ли он у него в списке <a class=link href=https://ru.wikipedia.org/wiki/HSTS target=_blank rel=noopener>HSTS</a> (HTTP Strict Transport Security, механизм принудительно активирующий защищенное соединение через протокол <code>https</code>), и если домен есть у него в списке - запрос будет отправлен используя протокол <code>https</code>, иначе - <code>http</code> (включается он с помощью HTTP заголовка на сервере домена <code>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload;</code>)</li>
</ul>
</li>
<li>Хоста или домена (<code>example.com</code>, <code>linux.org</code>)</li>
<li>Номера порта (опционально)
<ul>
<li>Для общения с веб-сервером на запрашиваемом домене, нам нужно установить TCP соединение с определенным портом. В случае, если он указан явно (<code>http://1.1.1.1:8080</code>) - то используется он, а иначе - используется стандартный порт для запрошенного протокола (80 для <code>http</code>, 443 для <code>https</code>, и так далее)</li>
</ul>
</li>
<li>И запроса (query, ресурс, URN) - строки адреса ресурса (например - адрес страницы)</li>
</ul>
<h3 id=dns>DNS</h3>
<p>После разбора адреса мы должны установить соединение с сервером, и сделать это по IP адресу (а не доменному имени, TCP/IP же), для чего нам нужно преобразовать имя домена в IP адрес <em>(другими словами - разрезолвить адрес; вообще, домены используются в первую очередь для удобства, и для возможности размещать несколько сайтов на одном IP адресе)</em>. Для этого:</p>
<ul>
<li>Сперва браузер смотрит в свой кэш (браузера)</li>
<li>Если там не обнаружено - то смотрит в файл <code>hosts</code> (в котором можно захардкодить любой IP для любого домена)</li>
<li>Если и там нет, но смотрит в кэше операционной системы (<code>systemd-resolve</code>)</li>
<li>Если нигде нет, то отправляется за адресом в сеть:
<ul>
<li>Отправляется запрос на сетевой DNS сервер (который был получен по DHCP или прописан ручками)
<ul>
<li>Если и у него нет, то он (сервер) идёт в корневой сервер, тот - в DNS сервер ответственный за зону (например - <code>.com</code>) - и так до тех пор, пока целевой NS (где хранятся записи) не будет найден</li>
<li>Когда целевой NS сервер достигнут (тот, где и содержится искомая запись для домена; обычно это <code>A</code> или <code>CNAME</code>) - то IP адрес сервера (<code>A</code> запись содержит IP, а вот с <code>CNAME</code> история резолвинга повторяется по кругу, так как она просто перенаправляет на другое доменное имя) возвращается по цепочке обратно (до запросившей её стороны), попутно кэшируясь на промежуточных серверах (если это необходимо и возможно)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=отправка-пакета>Отправка пакета</h3>
<p>Далее, когда нам известен IP адрес сервера, мы можем сформировать и отправить запрос. Вспоминая устройство стека протоколов TCP/IP происходит следующее:</p>
<ul>
<li>На <strong>прикладном уровне</strong> (application layer) браузером формируется запрос к серверу (будь то DNS, HTTP, HTTPS и тому подобное)</li>
<li>Далее, на <strong>транспортном уровне</strong> (transport layer, <code>TCP</code> или <code>UDP</code> протокол) в заголовки пакета добавляется порт, по которому нужно стучаться</li>
<li>На <strong>сетевом уровне</strong> (network layer, <code>IP</code> протокол) добавляется IP адрес к нашему пакету</li>
<li>На <strong>канальном уровне</strong> (data link layer) с помощью <a class=link href=https://ru.wikipedia.org/wiki/ARP target=_blank rel=noopener>ARP</a> (Address Resolution Protocol, протокол предназначенный для определения MAC-адреса другого компьютера по известному IP-адресу) определяется &ldquo;есть ли такой адрес в сети?&rdquo;
<ul>
<li>Если адрес есть в сети - то к нему передаётся пакет</li>
<li>В противном случае пакет передаётся на шлюз, который, поднимаясь по уровням выше (смотря на то, какой IP адрес и смотря свою таблицу маршрутизации) - направляет пакет в нужном направлении (пока не закончится TTL протокола IP, либо пакет не достигнет пункта своего назначения)</li>
</ul>
</li>
</ul>
<h3 id=tls-handshake>TLS Handshake</h3>
<p>Если запрос был отправлен по протоколу <code>https</code>, то наступает пора установить защищенное соединение (TLS Handshake), для этого:</p>
<ul>
<li>Браузер отправляет <code>Client hello</code> серверу со своей версией протокола <a class=link href=https://ru.wikipedia.org/wiki/TLS target=_blank rel=noopener>TLS</a> (например - <code>TLSv1.3</code>)</li>
<li>Сервер отвечает клиенту сообщением <code>Server hello</code>, содержащим версию TLS, выбранным методом шифрования, методом компрессии и публичным сертификатом сервиса (подписанный центром сертификации; сертификат содержит публичный ключ, который будет использоваться клиентом для шифрования)</li>
<li>Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации (если сертификат сервера подписан центром из списка - то ему можно доверять)</li>
<li>Клиент отправляет серверу некоторые данные, зашифрованные с помощью публичного ключа сервера</li>
<li>Сервер расшифровывает сообщение с помощью своего приватного ключа и генерирует симметричный мастер-ключ</li>
<li>Клиент отправляет серверу сообщение <code>Finished</code>, шифруя хэш передачи с помощью симметричного ключа</li>
<li>Сервер генерирует собственный хэш, а затем расшифровывает полученный от клиента хэш что бы проверить совпадает ли он с собственным; если совпадение обнаружено - сервер отправляет клиенту <code>Finished</code>, а так же зашифрованный собственный симметричный ключ</li>
<li>Далее клиент и сервер отправляют сообщения с помощью этого симметричного ключа</li>
</ul>
<h3 id=http-запрос>HTTP запрос</h3>
<p>На прикладном уровне браузер формирует запрос к серверу по <code>http</code> протоколу:</p>
<ul>
<li>В запрос вставляется используемый HTTP-метод (в нашем случае это будет <code>GET</code>)</li>
<li>Далее указывается URN (запрос, или query-строка)</li>
<li>Версия используемого протокола (например - <code>HTTP/1.1</code>)</li>
<li>И на новой строке указывается заголовок <code>Host</code> с именем запрашиваемого домена (так как на одном IP может быть несколько виртуальных серверов) и другие заголовки, формируемые самим браузером или иным ПО</li>
</ul>
<p>После формирования запроса на прикладном уровне он передаётся на транспортный уровень (и ниже) и по установленному ранее (в случае с <code>http</code>) TCP соединению доставляется на сервер. Сервер же:</p>
<ul>
<li>По номеру запрошенного порта определяет какому приложению он адресован</li>
<li>Смотрит в HTTP-заголовок <code>Host</code> для определения какому сайту (виртуальному серверу) он был адресован</li>
<li>Определяет, может ли виртуальный хост обработать запрошенный метод и куда его отдавать на обработку по запрошенному URN (строке запроса)</li>
</ul>
<p>После обработки запроса сервер вернёт клиенту ответ на его запрос, содержащий версию HTTP протокола (в случае с <code>HTTP/2</code>), код ответа, и заголовки/тело запроса, если они имеются. Далее браузер уже принимает ответы от сервера и отображает страницу (рендерит её, HTML парсится во много проходов, для чего создаётся DOM и CSSOM).</p>
<div class=video-wrapper>
<iframe loading=lazy src=https://www.youtube.com/embed/ylG8_d9Qk1U allowfullscreen title="YouTube Video"></iframe>
</div>
<h2 id=перечисли-все-уровни-модели-osi>Перечисли все уровни модели OSI?</h2>
<p><img src=/interview-section-network/osi.png width=1391 height=525 srcset="/interview-section-network/osi_hu5d3a8a6d700fe6f34701657e29ba5151_94299_480x0_resize_box_3.png 480w, /interview-section-network/osi_hu5d3a8a6d700fe6f34701657e29ba5151_94299_1024x0_resize_box_3.png 1024w" loading=lazy alt="Открытая сетевая модель OSI (Open Systems Interconnection model)" class=gallery-image data-flex-grow=264 data-flex-basis=635px></p>
<ul>
<li><strong>L7</strong> - Приложений или Прикладной (Application layer), например <code>HTTP</code>, <code>FTP</code>, <code>WebSocket</code></li>
<li><strong>L6</strong> - Представления (Presentation layer), например <code>ASCII</code>, <code>JPEG</code></li>
<li><strong>L5</strong> - Сеансовый (Session layer), например <code>RPC</code>, <code>L2TP</code>, <code>gRPC</code></li>
<li><strong>L4</strong> - Транспортный (Transport layer), например <code>TCP</code>, <code>UDP</code>, порты</li>
<li><strong>L3</strong> - Сетевой (Network layer), например <code>IPv4</code>, <code>IPsec</code>, <code>ICMP</code></li>
<li><strong>L2</strong> - Канальный (Data Link layer), например <code>PPP</code>, <code>IEEE</code>, <code>Ethernet</code>, сетевая карта</li>
<li><strong>L1</strong> - Физический (Physical layer), например <code>USB</code>, <code>RJ</code> (витая пара), радиоканал</li>
</ul>
<div class=video-wrapper>
<iframe loading=lazy src=https://www.youtube.com/embed/je0QFU7p5Oo allowfullscreen title="YouTube Video"></iframe>
</div>
<blockquote>
<p>Что можно почитать:</p>
<ul>
<li><a class=link href=https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI target=_blank rel=noopener>Wiki: Сетевая модель OSI</a></li>
</ul>
</blockquote>
<h2 id=что-такое-ip-адрес>Что такое IP адрес?</h2>
<p>Это уникальный <strong>внутри подсети</strong> идентификатор устройства <strong>сетевого</strong> уровня модели OSI (протокола IP), который состоит из 4 байт (32 бита; в IPv6 используется 128 бит для кодирования адреса). Всего может существовать 4_294_967_296 адресов.</p>
<p>IP адрес у устройства может быть статический (не меняется и всегда остается одним и тем же) и динамический (назначается на определенное время, затем заменяется другим).</p>
<h2 id=какие-режимы-передачи-данных-бывают>Какие режимы передачи данных бывают?</h2>
<p>Механизм передачи данных или информации между двумя связанными устройствами, соединенными по сети, называется режимом передачи.</p>
<ul>
<li>Симплексный - связь является однонаправленной, то есть данные могут передаваться только в одном направлении (как на улице с односторонним движением; пример - клавиатура, телевизионное вещание)</li>
<li><strong>Полу</strong>дуплексный - данные могут передаваться в обе стороны, но не одновременно (пример - рация)</li>
<li><strong>Полно</strong>дуплексный - данные могут <strong>одновременно</strong> передаваться в обе стороны (как на улице с двухсторонним движением)</li>
</ul>
<h2 id=что-такое-nat>Что такое NAT?</h2>
<p>Сети обычно проектируются с использованием частных IP адресов. Частные адреса используются внутри организации или площадки, чтобы позволить устройствам общаться локально, и они не маршрутизируются в интернете:</p>
<ul>
<li><code>10.0.0.0/8</code> (<code>10.0.0.0</code> – <code>10.255.255.255/8</code>, 16_777_216 хостов)</li>
<li><code>172.16.0.0/12</code> (<code>172.16.0.0</code> – <code>172.31.255.255/12</code>, 1_048_576 хостов)</li>
<li><code>192.168.0.0/16</code> (<code>192.168.0.0</code> – <code>192.168.255.255/16</code>, 65_536 хостов)</li>
</ul>
<p>Чтобы позволить устройству с приватным IPv4-адресом обращаться к устройствам и ресурсам за пределами локальной сети, приватный адрес сначала должен быть переведен на общедоступный (публичный) адрес, чем NAT (<strong>Network Address Translation</strong>) и занимается (переводит приватные адреса, в общедоступные).</p>
<p>NAT позволяет устройству с частным адресом IPv4 обращаться к ресурсам за пределами его частной сети. NAT в сочетании с частными адресами IPv4 оказался полезным методом сохранения общедоступных IPv4-адресов. Один общедоступный IPv4-адрес может быть использован сотнями, даже тысячами устройств, каждый из которых имеет частный IPv4-адрес. NAT имеет дополнительное преимущество, заключающееся в добавлении степени конфиденциальности и безопасности в сеть, поскольку он скрывает внутренние IPv4-адреса из внешних сетей.</p>
<p>Чаще всего для трансляции IP адресов NAT использует тип трансляции <strong>PAT</strong> (Port Address Translation) - транслирует несколько частных адресов на один или несколько общедоступных адресов. Фактически, PAT &ldquo;привязывает&rdquo; каждый сеанс выхода клиента из внутренней сети во внешнюю к своему случайному порту (из диапазона <code>0-511</code>, <code>512-1023</code> или <code>1024-65535</code>), тем самым &ldquo;запоминая&rdquo; куда (какому именно клиенту) отправить полученные в ответе пакеты обратно.</p>
<blockquote>
<p>Что можно почитать:</p>
<ul>
<li><a class=link href=https://wiki.merionet.ru/seti/13/nat-na-palcax-chto-eto/ target=_blank rel=noopener>NAT на пальцах - что это?</a></li>
</ul>
</blockquote>
<h2 id=расскажи-про-dhcp>Расскажи про DHCP?</h2>
<p>Dynamic Host Configuration Protocol (DHCP) - это прикладной протокол (<strong>L7</strong> по модели OS, передача данных производится при помощи протокола <strong>UDP</strong>), позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры (сетевую маску, адреса DNS серверов), необходимые для работы в сети TCP/IP. Доступен как для IPv4 (<code>DHCPv4</code>), так и для IPv6 (<code>DHCPv6</code>).</p>
<p>DHCPv4 включает три разных механизма распределения адресов:</p>
<ul>
<li>Ручное распределение (Manual Allocation) - администратор назначает предварительно установленный IPv4-адрес клиенту, а DHCP сервер передает IPv4-адрес на устройство</li>
<li>Автоматическое распределение(Automatic Allocation) - DHCPv4 автоматически назначает статический IPv4-адрес на устройство, выбирая его из пула доступных адресов. Нет аренды (<code>lease</code>), и адрес постоянно назначается устройству</li>
<li>Динамическое распределение (Dynamic Allocation) - DHCPv4 динамически назначает или дает в аренду IPv4-адрес из пула адресов в течение ограниченного периода времени, выбранного сервером, или пока клиент больше не нуждается в адресе</li>
</ul>
<p>DHCPv4 работает в режиме клиент (порт <code>67</code>) - сервер (порт <code>68</code>). Когда клиент взаимодействует с сервером DHCPv4, сервер назначает или арендует IPv4-адрес этому клиенту. Он подключается к сети с этим арендованным IP-адресом до истечения срока аренды и должен периодически связываться с сервером DHCP, чтобы продлить аренду. Этот механизм аренды гарантирует, что клиенты, которые перемещаются или выходят из строя - не сохраняют за собой адреса, которые им больше не нужны. По истечении срока аренды сервер DHCP возвращает адрес в пул, где он может быть перераспределен по мере необходимости.</p>
<p>Рассмотрим процесс получения адреса:</p>
<ul>
<li>Когда клиент хочет присоединиться к сети, он начинает четырех-этапный процесс для получения аренды. Он запускает процесс с широковещательным (<code>broadcast</code>) сообщением <code>DHCPDISCOVER</code> со своим собственным MAC-адресом для обнаружения доступных DHCP-серверов. Поскольку у клиента нет способа узнать подсеть, к которой он принадлежит, у сообщения <code>DHCPDISCOVER</code> адрес назначения IPv4 адреса - широковещательный адрес <code>255.255.255.255</code> (т.е. отправляется всем устройствам в его сети на <strong>сетевом</strong> L3 уровне) и целевой MAC-адрес <code>FF:FF:FF:FF:FF:FF</code> (тоже является широковещательным для <strong>канального</strong> L2 уровня). А поскольку у клиента еще нет настроенного адреса IPv4, то исходный IPv4-адрес - <code>0.0.0.0</code></li>
<li>Когда DHCPv4-сервер получает сообщение <code>DHCPDISCOVER</code>, он резервирует доступный IPv4-адрес для аренды клиенту. Сервер также создает запись ARP, состоящую из MAC-адреса клиента и арендованного IPv4-адреса DHCP сервер отправляет связанное сообщение <code>DHCPOFFER</code> запрашивающему клиенту, как одноадресная передача (<code>unicast</code>), используя MAC-адрес сервера в качестве исходного адреса и MAC-адрес клиента в качестве адреса доставки</li>
<li>Когда клиент получает <code>DHCPOFFER</code> с сервера, он отправляет обратно сообщение <code>DHCPREQUEST</code>. Это сообщение используется как для получения, так и для продления аренды</li>
<li>При получении сообщения <code>DHCPREQUEST</code> сервер проверяет информацию об аренде с помощью ICMP-запроса на этот адрес, чтобы убедиться, что он уже не используется и создает новую ARP запись для аренды клиента, а затем отвечает одноадресным <code>DHCPACK</code>-сообщением. Это сообщение является дубликатом <code>DHCPOFFER</code>, за исключением изменения поля типа сообщения. Когда клиент получает сообщение <code>DHCPACK</code>, он регистрирует информацию и выполняет поиск ARP для назначенного адреса. Если ответа на ARP нет, клиент знает, что адрес IPv4 действителен и начинает использовать его как свой собственный</li>
</ul>
<blockquote>
<p>Что можно почитать:</p>
<ul>
<li><a class=link href=https://ru.wikipedia.org/wiki/DHCP target=_blank rel=noopener>Wiki: DHCP</a></li>
</ul>
</blockquote>
<h2 id=что-такое-icmp>Что такое ICMP?</h2>
<p>Internet Control Message Protocol (ICMP) - это сетевой протокол (<strong>L3</strong> по модели OSI) который чаще всего используется для передачи сообщений об ошибках и других исключительных ситуациях, возникших при передаче данных. Хотя формально протокол использует IP (ICMP-пакеты инкапсулируются в IP пакеты), он является неотъемлемой частью IP-протокола и обязателен при реализации стека TCP/IP.</p>
<p>ICMP основан на протоколе IP. Каждое ICMP-сообщение инкапсулируется непосредственно в пределах одного IP-пакета, и, таким образом, как и <strong>UDP</strong> и в отличие от TCP, ICMP является т. н. «ненадежным» (не контролирующим доставку и её правильность).</p>
<p>Например, каждая машина, которая перенаправляет IP-пакеты (например маршрутизатор), уменьшает значение поля Time to live (<code>TTL</code>) заголовка IP-пакета на единицу; если <code>TTL</code> достигает 0, на источник пакета отправляется ICMP-сообщение о превышении <code>TTL</code>.</p>
<blockquote>
<p>Что можно почитать:</p>
<ul>
<li><a class=link href=https://ru.wikipedia.org/wiki/ICMP target=_blank rel=noopener>Wiki: ICMP</a></li>
</ul>
</blockquote>
<h2 id=что-такое-tcpip>Что такое TCP/IP?</h2>
<p>Изначально <strong>стек протоколов TCP/IP</strong> разработан в 1972 году на основе Network Control Protocol, но только спустя 4 года создана передача данных с применением протокола TCP. К концу 80-х было выделено две отдельные функции – TCP и IP. И уже к 1983 году удалось полностью перейти на современный протокол, что и считается отправной точкой развития Интернета.</p>
<p>Стек модели TCP/IP контролирует взаимодействие различных уровней системы (стек делится на отдельные уровни, каждый из которых направлен на решение определенной задачи). Ключевыми в нем являются сами протоколы, которые встраиваются друг в друга (работают одновременно, без конфликтов, сбоев и незавершенных операций) и обеспечивают передачу данных.</p>
<h3 id=ip-internet-protocol>IP (Internet Protocol)</h3>
<p>Маршрутизируемый протокол <strong>сетевого уровня</strong> модели стека протоколов TCP/IP, нужен для логической адресации устройств в компьютерной сети или сети передачи данных. Ключевые понятия о протоколе IP:</p>
<ul>
<li>Каждый узел на сетевом уровне в модели TCP/IP должен иметь <strong>IP-адрес</strong>, который состоит из 4 байт (<code>254.254.254.254</code>)</li>
<li>Минимальной единицей измерения данных здесь является <strong>IP-пакет</strong> (который чаще всего инкапсулируется в Ethernet кадр)</li>
<li>При доставке IP-пакета возможна его <strong>фрагментация</strong> (дробление) на более мелкие (получатель должен будет его собрать обратно). Так же возможен и запрет на фрагментацию (отправителю будет отправлен ICMP-сообщение об ошибке)</li>
<li>Функция IP протокола заключается в том, чтобы <strong>доставить пакет из точки А в точку Б</strong> через множество промежуточных сетей (при этом IP-пакеты при передаче данных могут быть изменены, потеряны, повреждены, пакеты могут прийти получателю не в той последовательности, в которой они были отправлены - обо всем этом протокол IP не заботится, его задачей является организовать маршрут)</li>
<li>Протокол использует передачу данных <strong>без установки соединения</strong></li>
</ul>
<p>Размер заголовка IP-пакета составляет от 20 (обычный заголовок без дополнительных опций) до 60 байт.</p>
<h3 id=tcp-transmission-control-protocol>TCP (Transmission Control Protocol)</h3>
<p>Протокол <strong>транспортного уровня</strong>, управляющий передачей данных. Фактически, если IP протокол связывает между собой машины в сети, то <strong>TCP связывает конкретные приложения используя порты</strong> <em>(которых одновременно на машине может быть до 65535, т.к. номер порта занимает 2 байта)</em>. Ключевые характеристики:</p>
<ul>
<li><strong>Требует установки соединения</strong> (для этого сервер делает passive open - ждёт входящие запросы, а клиент active open - отправляет серверу <code>SYN</code>, на что сервер должен ответить <code>ACK</code> + <code>SYN</code>, клиент в ответ на это должен ответить <code>ACK</code>, и после этого соединение считается установленным)</li>
<li>Нумерует пакеты, посылает подтверждения о получении данных (<code>ACK</code>) и запрашивает повторную передачу, если данные не получены или искажены (или истёк таймаут для ответа), т.е. <strong>обеспечивает гарантию доставки</strong></li>
<li>Любое установленное TCP-соединение симметрично, и пакеты с данными по нему всегда идут в обе стороны (двунаправленная взаимосвязь)</li>
<li>Когда один из узлов решает, что пора заканчивать соединение, он посылает специальный пакет <code>FIN</code>, после этого узлы прощаются и разрывают соединение</li>
<li>Использование принципа &ldquo;скользящего окна&rdquo; для увеличения скорости передачи (<code>ACK</code> не каждого сообщения, а определенной &ldquo;пачки&rdquo;; причём размер окна может меняться динамически)</li>
<li>Контролирует загруженность соединения</li>
</ul>
<h3 id=udp-user-datagram-protocol>UDP (User Datagram Protocol)</h3>
<p>Протокол <strong>транспортного уровня</strong>, передающий сообщения-датаграммы <strong>без необходимости</strong> установки соединения в IP-сети. UDP <strong>допускает</strong> потери пакетов, их дублирование, перемешивание, но контролирует целостность полученных датаграмм. Так же UDP не контролирует загруженность канала (более жадный).</p>
<p>Благодаря такой не избирательности и бесконтрольности, UDP доставляет пакеты данных (датаграммы) гораздо быстрее, потому для приложений, которые рассчитаны на широкую пропускную способность и быстрый обмен, UDP можно считать оптимальным протоколом. К таковым относятся сетевые и браузерные игры, а также программы просмотра потокового видео и приложения для видео (или голосовой) связи - от потери пакета, полной или частичной, ничего не меняется, повторять запрос не обязательно, зато загрузка происходит намного быстрее.</p>
<p>Я бы рассказал отличную шутку про <code>UDP</code>, но боюсь, не до всех она дойдёт 😄</p>
<div class=video-wrapper>
<iframe loading=lazy src=https://www.youtube.com/embed/Y1g6RabHBoA allowfullscreen title="YouTube Video"></iframe>
</div>
<blockquote>
<p>Что можно почитать:</p>
<ul>
<li><a class=link href=https://ru.wikipedia.org/wiki/IP target=_blank rel=noopener>Wiki: IP</a></li>
<li><a class=link href=https://zametkinapolyah.ru/kompyuternye-seti/4-3-struktura-i-zagolovok-ip-paketa-v-protokole-ipv4.html target=_blank rel=noopener>IP-пакет в протоколе IPv4. Структура, заголовок и поля в IP-пакете</a></li>
<li><a class=link href=https://professorweb.ru/my/csharp/web/level1/1_4.php target=_blank rel=noopener>Протоколы TCP и UDP</a></li>
</ul>
</blockquote>
<h2 id=какие-бывают-версии-http>Какие бывают версии HTTP?</h2>
<p>HTTP (HyperText Transfer Protocol) - это клиент-серверный протокол прикладного уровня, реализованный поверх протокола TCP/IP <em>(третья версия протокола работает используя UDP)</em>. Сам HTTP зависит от протокола TCP/IP (UDP), позволяющего посылать и отправлять запросы между клиентом и сервером. По умолчанию используется 80 порт TCP, но могут использоваться и другие (HTTPS, например, использует 443 порт).</p>
<p>Выполнить простейший HTTP запрос можно с помощью <code>telnet</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ telnet google.com <span class=m>80</span>
Trying 142.251.1.113...
Connected to google.com.
Escape character is <span class=s1>&#39;^]&#39;</span>.
GET /robots.txt HTTP/1.1
Host: google.com

<span class=c1># просто 2 пустые строки (2 раза нажми enter)</span>
HTTP/1.1 <span class=m>301</span> Moved Permanently
<span class=o>(</span>headers<span class=o>)</span>
<span class=o>(</span>content<span class=o>)</span>
</code></pre></div><h3 id=http09><code>HTTP/0.9</code></h3>
<p>Появился в конце 1990 года (разработан Тимом Бернерсом-Ли) и был экстремально простым - запрос состоял из одной строки и умел только метод <code>GET</code> (<code>GET /mypage.html</code>), а ответ в свою очередь только контент ответа (обычно HTML; без заголовков) и даже без кода ответа.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET /mypage.html
</span><span class=err>
</span><span class=err>&lt;HTML&gt;
</span><span class=err>A very simple HTML page
</span><span class=err>&lt;/HTML&gt;
</span></code></pre></div><h3 id=http10><code>HTTP/1.0</code></h3>
<p><a class=link href=https://datatracker.ietf.org/doc/html/rfc1945 target=_blank rel=noopener>Спецификация (RFC 1945)</a> была опубликована в ноябре 1996 года. Информация о версии протокола теперь отправляется с каждым запросом (<code>GET /mypage.html HTTP/1.0</code>). Код ответа отправляется в самом начале ответа (<code>200 OK</code>). Добавлена <strong>поддержка заголовков</strong> (как запросов, так и ответов) для передачи мета-информации. К методу <code>GET</code> добавились <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>LINK</code>, <code>UNLINK</code>. Кроме того, с помощью заголовка <code>Content-Type</code> стало возможным передавать разные типы контента:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/mypage.html</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.0</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>NCSA_Mosaic/2.0 (Windows 3.1)</span>

<span class=g>200 OK
</span><span class=g>Date: Tue, 15 Nov 1996 08:12:31 GMT
</span><span class=g>Server: CERN/3.0 libwww/2.17
</span><span class=g>Content-Type: text/html
</span><span class=g>&lt;HTML&gt;
</span><span class=g>A page with an image &lt;IMG SRC=&#34;/myimage.gif&#34;&gt;
</span><span class=g>&lt;/HTML&gt;
</span></code></pre></div><p>Для каждого запроса и ответа между клиентом и сервером создаётся новое TCP-соединение (пожалуй, главный недостаток, поскольку каждое новое TCP-соединение требует &ldquo;тройного рукопожатия&rdquo;, за которым следует <a class=link href=https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B4%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D1%82%D0%B0%D1%80%D1%82 target=_blank rel=noopener>медленный старт</a>).</p>
<h3 id=http11><code>HTTP/1.1</code></h3>
<p>Появился всего через несколько месяцев после версии <code>1.1</code> (в январе 1997 года, <a class=link href=https://datatracker.ietf.org/doc/html/rfc2068 target=_blank rel=noopener>RFC 2068</a>, и по 2014 год выходили &ldquo;дополнительные&rdquo; RFC для этой версии протокола), и изменения были следующие:</p>
<ul>
<li>Соединение могло быть пере-использовано (не требуется постоянно поднимать новое TCP соединение для запроса, управляется с помощью заголовка <code>Connection: close</code> или <code>Connection: keep-alive</code>)</li>
<li>Добавлена поддержка заголовка <a class=link href=https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Host target=_blank rel=noopener><code>Host</code></a> содержащего имя домена, для которого предназначен запрос (опционально и номер порта), что позволило держать на одном IP множество доменов (сайтов)</li>
<li>Добавлены методы <code>OPTIONS</code>, <code>TRACE</code>, <code>PATCH</code>, <code>CONNECT</code> (последний добавлен в 2014 году)</li>
<li>Добавлено согласование контента (включающее в себя язык <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language target=_blank rel=noopener><code>Accept-Language: &lt;lang></code></a>, кодировку <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding target=_blank rel=noopener><code>Accept-Encoding: &lt;directives></code></a>, тип данных - <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept target=_blank rel=noopener><code>Accept: &lt;mime_type>/*</code></a> и другие)</li>
<li>Добавлены заголовки управления кэшированием контента (<a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control target=_blank rel=noopener><code>Cache-Control: &lt;directives></code></a>, <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires target=_blank rel=noopener><code>Expires: &lt;http-date></code></a>, <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified target=_blank rel=noopener><code>Last-Modified: &lt;when></code></a>, <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag target=_blank rel=noopener><code>ETag: &lt;hash></code></a> и другие)</li>
<li>Добавлена возможность доставки контента частями <em>(или чанками, chunks)</em>, управляется заголовком <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding target=_blank rel=noopener><code>Transfer-Encoding: &lt;directives></code></a> и другими (в этом случае нет необходимости заранее знать точный размер всего тела HTTP-сообщения); HTTP/2 не поддерживает эту фичу, но имеет другие, более эффективные механизмы для потовой передачи данных</li>
<li>Добавлена конвейерная обработка, позволяющая передавать сразу несколько запросов в одном соединении, не ожидая соответствующих ответов (но нужно помнить, что сервер должен отдавать ответы в строго той же последовательности, как получались запросы, и один затормозивший запрос тормозит все последующие в &ldquo;пачке&rdquo;); в HTTP/2 эта фича была заменена на мульти-плексирование</li>
<li>Добавлена возможность использования заголовка <a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade target=_blank rel=noopener><code>Upgrade: &lt;protocol>[/&lt;version>]</code></a> для переключения на другой протокол, например <code>HTTP/2.0</code> или <code>WebSockets</code>, и эта функциональность присуща только версии <code>HTTP/1.1</code></li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/en-US/docs/Glossary/Simple_header</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>developer.mozilla.org</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>en-US,en;q=0.5</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate, br</span>
<span class=n>Referer</span><span class=o>:</span> <span class=l>https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</span>

<span class=g>200 OK
</span><span class=g>Connection: Keep-Alive
</span><span class=g>Content-Encoding: gzip
</span><span class=g>Content-Type: text/html; charset=utf-8
</span><span class=g>Date: Wed, 20 Jul 2016 10:55:30 GMT
</span><span class=g>Etag: &#34;547fa7e369ef56031dd3bff2ace9fc0832eb251a&#34;
</span><span class=g>Keep-Alive: timeout=5, max=1000
</span><span class=g>Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
</span><span class=g>Server: Apache
</span><span class=g>Transfer-Encoding: chunked
</span><span class=g>Vary: Cookie, Accept-Encoding
</span><span class=g>
</span><span class=g>(content)
</span></code></pre></div><h3 id=http2><code>HTTP/2</code></h3>
<p><a class=link href=https://datatracker.ietf.org/doc/html/rfc7540 target=_blank rel=noopener>Спецификация (RFC 7540)</a> была опубликована в мае 2015 года, основан на протоколе <a class=link href=https://ru.wikipedia.org/wiki/SPDY target=_blank rel=noopener>SPDY</a> <em>(a.k.a &ldquo;speedy&rdquo;, разработан Google в 2012 году, поддержка которого прекратилась в феврале 2015 в пользу <code>HTTP/2</code>; при его использовании время загрузки страниц уменьшалось на ~36%)</em>. В 2021 году порядка <strong>50,2%</strong> самых популярных сайтов поддерживают этот протокол.</p>
<p>В отличии от <code>HTTP/1.1</code>:</p>
<ul>
<li>Протокол стал <strong>бинарным</strong> (сообщения быстрее разбираются автоматически, но неудобны для чтения человеком), основные составляющие <code>HTTP/2</code> — фреймы (Frames) и потоки (Streams):
<ul>
<li>HTTP-сообщения состоят из одного или более фреймов (<code>HEADERS</code> для мета-данных, <code>DATA</code> для данных, <code>RST_STREAM</code> для прерывания потоков - при этом соединение останется открытым что позволяет работать остальным потокам, <code>SETTINGS</code>, <code>PRIORITY</code> и <a class=link href=https://datatracker.ietf.org/doc/html/rfc7540#section-6 target=_blank rel=noopener>другие</a>)</li>
<li>Каждый запрос и ответ HTTP/2 получает <strong>уникальный ID</strong> потока и разделяется на фреймы</li>
<li>Фреймы представляют собой просто бинарные части данных; коллекция фреймов называется потоком (Stream)</li>
<li>Каждый фрейм содержит ID потока, показывающий, к какому потоку он принадлежит; а также каждый фрейм содержит общий заголовок (идентификатор потока уникален; каждый клиентский запрос использует <strong>не</strong>чётные id, а ответ от сервера — чётные)</li>
</ul>
</li>
<li>Добавлено <strong>мультиплексирование</strong> - передача нескольких асинхронных HTTP-запросов по одному TCP-соединению
<ul>
<li>Ответ сервера не имеет порядка, и клиент использует ID потока, чтобы понять, к какому потоку принадлежит тот или иной пакет</li>
<li>Клиенту не придётся простаивать, ожидая обработки длинного запроса, ведь во время ожидания могут обрабатываться остальные запросы</li>
</ul>
</li>
<li>Реализовано сжатие передаваемых заголовков (методом <code>HPACK</code>)
<ul>
<li>Клиент и сервер поддерживают единую таблицу заголовков</li>
<li>Повторяющиеся заголовки (например, <code>user-agent</code>) опускаются при повторных запросах и ссылаются на их позицию в таблице заголовков</li>
<li>Сами заголовки ничем не отличаются от <code>HTTP/1.1</code>, но добавились псевдо-заголовки вида <code>:method</code>, <code>:scheme</code>, <code>:host</code>, <code>:path</code></li>
</ul>
</li>
<li>Появился Server Push - несколько ответов на один запрос
<ul>
<li>Сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом, используя специальный фрейм <code>PUSH_PROMISE</code></li>
</ul>
</li>
<li>Добавлена явная приоритизация запросов (используя фрейм <code>HEADERS</code> которым открывается поток, или в любое другое время используя фрейм <code>PRIORITY</code>)</li>
<li>Повышена безопасность (хотя спецификация не требует шифрования для <code>HTTP/2</code>, оно всё равно станет обязательным по умолчанию, так как браузеры без шифрования не работают с этим протоколом)</li>
</ul>
<p>Так же стоит знать, что мультиплексирование ведёт к проблеме доставки контента при ошибках на сетевом уровне. Представьте, что мы асинхронно выполняем 5 запросов к одному серверу. При использовании <code>HTTP/2</code> все эти запросы будут выполняться в рамках одного TCP-соединения, а значит, если один из сегментов любого запроса потеряется или придёт неверно, передача всех запросов и ответов остановится, пока не будет восстановлен потерявшийся сегмент (у этой проблемы есть и название - &ldquo;head-of-line blocking&rdquo;). Очевидно, что <strong>чем хуже качество соединения, тем медленнее работает HTTP/2</strong> (когда потерянные пакеты составляют всего <strong>2%</strong> от всех, <code>HTTP/1.1</code> в браузере показывает себя лучше, чем <code>HTTP/2</code> за счёт того, что открывает 6 соединений, а не одно).</p>
<h3 id=http3><code>HTTP/3</code></h3>
<p>Проектируется для решения проблем <code>HTTP/2</code> и сейчас проходит тестирование с опубликованной спецификацией. Новый протокол должен решать текущие проблемы скорости, надёжности и безопасности для широкого сектора устройств. <code>HTTP/3</code> строится на основе нового протокола <a class=link href=https://ru.wikipedia.org/wiki/QUIC target=_blank rel=noopener>QUIC</a>, разрабатываемого в Google с 2012 года. Основные отличия от предшественника:</p>
<ul>
<li>Вместо TCP будет использоваться <strong>UDP</strong></li>
<li>QUIC сам обеспечивает мультплексирование, и потеря одного пакета повлияет только на имеющий к этому пакету поток, другие потоки в рамках соединения продолжат свою работу</li>
<li>Заголовки запросов и ответов сжимаются <code>QPACK</code> вместо <code>HPACK</code></li>
<li>Для шифрования используется TLS 1.3 (эффективно использующийся в HTTPS) - оно включено в протокол
<ul>
<li>Это позволяет устанавливать соединение и обмениваться публичными ключами за одно рукопожатие, а также позволяет использовать хитрый механизм 0-RTT handshake и вообще избежать задержек при рукопожатии</li>
<li>Кроме того, теперь можно шифровать отдельные пакеты данных (это позволяет не ждать завершения приёма данных из стрима, а расшифровывать полученные пакеты независимо)</li>
</ul>
</li>
<li>Концепция лёгких стримов позволяет отвязать соединение от IP-адреса клиента (например, когда клиент переключается с одной Wi-Fi точки доступа на другую, изменяя свой IP - при использовании TCP происходит длительный процесс, в ходе которого существующие TCP-соединения отваливаются по таймауту; в случае с QUIC, клиент просто продолжает посылать серверу пакеты с нового IP со старым ID стрима)</li>
<li>QUIC реализуется на уровне приложения, а не операционной системы (позволяет быстрее вносить изменения в протокол, т.к. чтобы получить обновление достаточно просто обновить библиотеку, а не ждать новую версию ОС)</li>
</ul>
<p>Последние версии браузеров Chrome, Firefox, Edge, Opera и некоторые мобильные браузеры уже поддерживают работу по HTTP/3, но для работы должна быть и поддержка со стороны сервера. На данный момент <code>HTTP/3</code> активно используется в Google и Cloudflare.</p>
<p>По статистике на июль 2021 года только 20% вебсайтов доступны по <code>HTTP/3</code>. По отчетам Google через gQUIC страницы загружаются примерно на 5% быстрее, а в потоковом видео на 30% меньше подвисаний по сравнению с TCP.</p>
<p>К слабым сторонам протокола пока что можно отнести высокое потребление CPU, жадность (unfairness) к пропускной способности канала и более медленная передача небольших (до 10 кб) объектов. А так же неготовность интернета к полному переходу на UDP.</p>
<blockquote>
<p>Что можно почитать:</p>
<ul>
<li><a class=link href=https://developer.mozilla.org/ru/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP target=_blank rel=noopener>Evolution of HTTP</a></li>
<li><a class=link href=https://habr.com/ru/post/308846/ target=_blank rel=noopener>Путь к HTTP/2</a></li>
<li><a class=link href=https://ru.hexlet.io/blog/posts/http-3-proshloe-nastoyaschee-i-buduschee target=_blank rel=noopener>HTTP/3: прошлое, настоящее и будущее</a></li>
<li><a class=link href="https://developers.google.com/web/fundamentals/performance/http2?hl=ru" target=_blank rel=noopener>Введение в HTTP/2</a></li>
</ul>
</blockquote>
<h2 id=как-работает-https>Как работает HTTPS?</h2>
<p>Проблема протокола HTTP в том, что данные передаются по сети в открытом <strong>незашифрованном виде</strong>. Это позволяет злоумышленнику слушать передаваемые пакеты и извлекать любую информацию из параметров, заголовков и тела сообщения. Для устранения уязвимости был разработан <strong>HTTPS</strong> (<strong>S</strong> в конце значит <strong>Secure</strong>) - он, хоть не является отдельным протоколом, всего лишь HTTP поверх SSL (а позже TLS), позволяет безопасно обмениваться данными. В отличие от HTTP со стандартным TCP/IP портом 80, для HTTPS используется порт 443.</p>
<p>Для того, чтоб ваш сервер был доступен по <code>https</code> необходимо выпустить сертификат, подписанный центром сертификации (который является доверенным), и сконфигурировать используемое ПО на его использование.</p>
<h3 id=ssl>SSL</h3>
<p><strong>Secure Sockets Layer</strong> (SSL) - это криптографический протокол, обеспечивающий безопасное общение пользователя и сервера по небезопасной сети. Располагается между транспортным уровнем и уровнем программы-клиента (FTP, HTTP и т.п.). С 2015 года признан полностью устаревшим.</p>
<h3 id=tls>TLS</h3>
<p><strong>Transport Layer Security</strong> - это развитие идей, заложенных в протоколе SSL. На данный момент актуальной является версия <code>TLSv1.3</code>. Протокол обеспечивает услуги: приватности (сокрытие передаваемой информации), целостности (обнаружение изменений), аутентификации (проверка авторства). Достигаются они за счет гибридного шифрования, то есть совместного использования ассиметричного и симметричного шифрования.</p>
<h3 id=шифрование>Шифрование</h3>
<p><strong>Симметричное шифрование</strong> предполагает наличие общего ключа одновременно у отправителя и получателя, с помощью которого происходит шифровка и дешифровка данных.</p>
<p>При использовании <strong>ассиметричного шифрования</strong> существует открытый ключ, который можно свободно распространять, и закрытый ключ, который держится в секрете у одной из сторон. Этот тип работает медленно, относительно симметричного шифрования, однако скомпрометировать закрытый ключ сложнее.</p>
<p>Чтобы решить проблему производительности (шифровать ассиметрично абсолютно все - сложно), в TLS используется <strong>гибридное шифрование</strong> - общий ключ для симметричного шифрования данных передается от клиента серверу зашифрованным открытым ключом сервера, после этого сервер может его расшифровать своим закрытым ключом и использовать для обмена данными с клиентом.</p>
<p>Для установки безопасного соединения происходит TLS Handshake, который схематично выглядит следующим образом:</p>
<p><img src=/interview-section-network/tls_handshake.png width=850 height=956 srcset="/interview-section-network/tls_handshake_hua679145ce84acf1bb56a212c9f0aaeb4_55169_480x0_resize_box_3.png 480w, /interview-section-network/tls_handshake_hua679145ce84acf1bb56a212c9f0aaeb4_55169_1024x0_resize_box_3.png 1024w" loading=lazy alt="TLS Handshake" class=gallery-image data-flex-grow=88 data-flex-basis=213px></p>
<blockquote>
<p>Что можно почитать:</p>
<ul>
<li><a class=link href=https://habr.com/ru/post/593507/ target=_blank rel=noopener>Основы HTTPS, TLS, SSL</a></li>
</ul>
</blockquote>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/network/>network</a>
</section>
<div style=display:flex;justify-content:space-between;margin-top:1em>
<div>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>WTFPL</span>
</section>
</div>
<div style=margin-left:auto><section style=height:100%>
<a href=https://github.com/iddqd-uk/blog/edit/master/content/post/interview-section-network/index.md style=font-size:.7em;color:var(--card-text-color-tertiary)>Редиктировать</a>
</section>
</div>
</div></footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Может быть интересно</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/yandex-interview-questions/>
<div class=article-image>
<img src=/yandex-interview-questions/cover.091604f6242b958abb20698472bc1427_hu189ac99d92bfe66fb9120bb88310aa74_36894_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post Yandex Interview Questions" data-key=yandex-interview-questions data-hash="md5-CRYE9iQrlYq7IGmEcrwUJw==">
</div>
<div class=article-details>
<h2 class=article-title>Yandex Interview Questions</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/interview-section-golang-coding/>
<div class=article-image>
<img src=/interview-section-golang-coding/cover.1e3a141317c9794e24ee16d558687723_hu6c745680144d0a85df5a67b80461116c_57776_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post Задачи и решения для лайв-кодинга на Go" data-key=interview-section-golang-coding data-hash="md5-HjoUExfJeU4k7hbVWGh3Iw==">
</div>
<div class=article-details>
<h2 class=article-title>Задачи и решения для лайв-кодинга на Go</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/interview-section-golang/>
<div class=article-image>
<img src=/interview-section-golang/cover.f4a8a0debf71679bfd758da95e284bcb_hu032bd5f7e68e559a642ecef405e28712_26494_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post Вопросы и ответы для собеседования Go-разработчика" data-key=interview-section-golang data-hash="md5-9Kig3r9xZ5v9dY2pXihLyw==">
</div>
<div class=article-details>
<h2 class=article-title>Вопросы и ответы для собеседования Go-разработчика</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<script src=https://utteranc.es/client.js repo=iddqd-uk/blog issue-term=pathname crossorigin=anonymous async></script>
<style>.utterances{max-width:unset}</style>
<script>function setUtterancesTheme(b){let a=document.querySelector('.utterances iframe');a&&a.contentWindow.postMessage({type:'set-theme',theme:`github-${b}`},'https://utteranc.es')}addEventListener('message',a=>{if(a.origin!=='https://utteranc.es')return;setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener('onColorSchemeChange',a=>{setUtterancesTheme(a.detail)})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2014 -
2025 blog [dot] iddqd
</section>
<section class=powerby>
Make love, not war <br>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Содержание</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#что-происходит-после-ввода-адреса-в-браузер>Что происходит после ввода адреса в браузер?</a>
<ol>
<li><a href=#dns>DNS</a></li>
<li><a href=#отправка-пакета>Отправка пакета</a></li>
<li><a href=#tls-handshake>TLS Handshake</a></li>
<li><a href=#http-запрос>HTTP запрос</a></li>
</ol>
</li>
<li><a href=#перечисли-все-уровни-модели-osi>Перечисли все уровни модели OSI?</a></li>
<li><a href=#что-такое-ip-адрес>Что такое IP адрес?</a></li>
<li><a href=#какие-режимы-передачи-данных-бывают>Какие режимы передачи данных бывают?</a></li>
<li><a href=#что-такое-nat>Что такое NAT?</a></li>
<li><a href=#расскажи-про-dhcp>Расскажи про DHCP?</a></li>
<li><a href=#что-такое-icmp>Что такое ICMP?</a></li>
<li><a href=#что-такое-tcpip>Что такое TCP/IP?</a>
<ol>
<li><a href=#ip-internet-protocol>IP (Internet Protocol)</a></li>
<li><a href=#tcp-transmission-control-protocol>TCP (Transmission Control Protocol)</a></li>
<li><a href=#udp-user-datagram-protocol>UDP (User Datagram Protocol)</a></li>
</ol>
</li>
<li><a href=#какие-бывают-версии-http>Какие бывают версии HTTP?</a>
<ol>
<li><a href=#http09><code>HTTP/0.9</code></a></li>
<li><a href=#http10><code>HTTP/1.0</code></a></li>
<li><a href=#http11><code>HTTP/1.1</code></a></li>
<li><a href=#http2><code>HTTP/2</code></a></li>
<li><a href=#http3><code>HTTP/3</code></a></li>
</ol>
</li>
<li><a href=#как-работает-https>Как работает HTTPS?</a>
<ol>
<li><a href=#ssl>SSL</a></li>
<li><a href=#tls>TLS</a></li>
<li><a href=#шифрование>Шифрование</a></li>
</ol>
</li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
<script data-no-instant>(function(){const a=document.querySelectorAll('.outdated-post'),b=new Date;for(let c=0,f=a.length;c<f;c++){const d=a[c],e=new Date(d.getAttribute('data-posted-at'));if(!isNaN(e.valueOf())&&e.getFullYear()>1){const a=Math.abs(b.getTime()-e.getTime()),c=Math.ceil(a/(1e3*3600*24));c>=547&&(d.style.display='block',d.style.visibility='visible')}}})()</script>
</body>
</html>