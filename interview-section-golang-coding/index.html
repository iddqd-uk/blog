<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="В этой заметки содержатся (и, возможно, будут периодически добавляться) задачи на лайв-кодинг для Go разработчиков, что встречаются на интервью, либо являются хорошими кандидатами для этого.
Лучше всего чтоб ты самостоятельно попытался решить эти задачи, и только для проверки результата смотрел код готовых решений.
"><title>Задачи и решения для лайв-кодинга на Go</title>
<link rel=canonical href=https://blog.iddqd.uk/interview-section-golang-coding/>
<link rel=stylesheet href=https://blog.iddqd.uk/scss/style.min.471bdc6463fbad60208a71af0eed86d783b5cf8d4d274ae3d77e962c37962c18.css>
<meta property="og:title" content="Задачи и решения для лайв-кодинга на Go">
<meta property="og:description" content="В этой заметки содержатся (и, возможно, будут периодически добавляться) задачи на лайв-кодинг для Go разработчиков, что встречаются на интервью, либо являются хорошими кандидатами для этого.
Лучше всего чтоб ты самостоятельно попытался решить эти задачи, и только для проверки результата смотрел код готовых решений.
">
<meta property="og:url" content="https://blog.iddqd.uk/interview-section-golang-coding/">
<meta property="og:site_name" content="blog [dot] iddqd">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="go"><meta property="article:tag" content="coding"><meta property="article:published_time" content="2022-02-08T06:47:03+00:00"><meta property="article:modified_time" content="2022-02-08T06:47:03+00:00"><meta property="og:image" content="https://blog.iddqd.uk/interview-section-golang-coding/cover.png">
<meta name=twitter:title content="Задачи и решения для лайв-кодинга на Go">
<meta name=twitter:description content="В этой заметки содержатся (и, возможно, будут периодически добавляться) задачи на лайв-кодинг для Go разработчиков, что встречаются на интервью, либо являются хорошими кандидатами для этого.
Лучше всего чтоб ты самостоятельно попытался решить эти задачи, и только для проверки результата смотрел код готовых решений.
"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.iddqd.uk/interview-section-golang-coding/cover.png">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1B4Z5Q844N"></script>
<script>var dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-1B4Z5Q844N',{anonymize_ip:!0})}</script>
<link rel=apple-touch-icon sizes=180x180 href="https://blog.iddqd.uk/apple-touch-icon.png?v=1755397328">
<link rel=icon type=image/png sizes=32x32 href="https://blog.iddqd.uk/favicon-32x32.png?v=1755397328">
<link rel=icon type=image/png sizes=16x16 href="https://blog.iddqd.uk/favicon-16x16.png?v=1755397328">
<link rel=manifest href=https://blog.iddqd.uk/webmanifest.json>
<meta name=msapplication-TileColor content="#303030">
<meta name=theme-color content="#303030">
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"dark")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Назад</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<div class=article-image>
<a href=/interview-section-golang-coding/>
<img src=/interview-section-golang-coding/cover_hu6c745680144d0a85df5a67b80461116c_57776_800x0_resize_box_3.png srcset="/interview-section-golang-coding/cover_hu6c745680144d0a85df5a67b80461116c_57776_800x0_resize_box_3.png 800w, /interview-section-golang-coding/cover_hu6c745680144d0a85df5a67b80461116c_57776_1600x0_resize_box_3.png 1600w" width=800 height=331 loading=lazy alt="Featured image of post Задачи и решения для лайв-кодинга на Go">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/interview/ style=background-color:#0b2a4f;color:#fff>
Interview
</a>
<a href=/categories/go/ style=background-color:#4fa2ac;color:#fff>
Go
</a>
</header>
<h2 class=article-title>
<a href=/interview-section-golang-coding/>Задачи и решения для лайв-кодинга на Go</a></h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2022.02.08</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
Время чтения: 14 мин.
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<div class=outdated-post style=display:none data-posted-at=2022-02-08>
<strong>Внимание!</strong> Данный пост был опубликован более года назад и, возможно, уже утратил свою былую актуальность. Но это не точно.
</div>
<p>В этой заметки содержатся (и, возможно, будут периодически добавляться) задачи на лайв-кодинг для Go разработчиков, что встречаются на интервью, либо являются хорошими кандидатами для этого.</p>
<p>Лучше всего чтоб ты самостоятельно попытался решить эти задачи, и только для проверки результата смотрел код готовых решений.</p>
<div class=toc>
<nav id=TableOfContents>
<ol>
<li><a href=#найти-пересечение-двух-неупорядоченных-слайсов-любой-длины>Найти пересечение двух неупорядоченных слайсов любой длины</a></li>
<li><a href=#развернуть-односвязный-список>Развернуть односвязный список</a></li>
<li><a href=#написать-генератор-случайных-чисел>Написать генератор случайных чисел</a></li>
<li><a href=#слить-n-каналов-в-один>Слить N каналов в один</a></li>
<li><a href=#сделать-конвейер-чисел>Сделать конвейер чисел</a></li>
<li><a href=#сделать-кастомную-waitgroup-на-семафоре>Сделать кастомную WaitGroup на семафоре</a></li>
<li><a href=#алгоритм-бинарного-двоичного-поиска>Алгоритм бинарного (двоичного) поиска</a></li>
<li><a href=#обход-ссылок-из-файла>Обход ссылок из файла</a></li>
</ol>
</nav>
</div>
<h2 id=найти-пересечение-двух-неупорядоченных-слайсов-любой-длины>Найти пересечение двух неупорядоченных слайсов любой длины</h2>
<p>Перечесение - это те элементы, что присутствуют в обоих слайсах, то есть:</p>
<ul>
<li><code>f([]int{1, 2, 2, 1}, []int{2, 2}) == []int{2, 2}</code></li>
<li><code>f([]int{4, 9, 5}, []int{9, 4, 9, 8, 4}) == []int{4, 9} or []int{9, 4}</code></li>
</ul>
<p>Можно решить сортировкой, за более долгое время, но без выделения дополнительной памяти. А можно выделить дополнительную память и решить за линейное время:</p>
<details class=spoiler>
<summary>Решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>intersection</span><span class=p>(</span><span class=nx>one</span><span class=p>,</span> <span class=nx>two</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>m</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>uint</span><span class=p>)</span> <span class=c1>// не делаем пре-аллокацию, так как не знаем количество дублей
</span><span class=c1></span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>one</span> <span class=p>{</span> <span class=c1>// пробегаясь по первому слайсу &#34;прогреваем&#34; карту
</span><span class=c1></span>    <span class=nx>m</span><span class=p>[</span><span class=nx>one</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span><span class=o>++</span> <span class=c1>// так как нулевое значение для uint это 0 - то просто увеличиваем
</span><span class=c1></span>	<span class=p>}</span>

	<span class=kd>var</span> <span class=nx>result</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// тоже без пре-аллокации, т.к. не знаем сколько пересечений
</span><span class=c1></span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>two</span> <span class=p>{</span> <span class=c1>// пробегаясь по второму - ищем пересечение
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=nx>two</span><span class=p>[</span><span class=nx>i</span><span class=p>]];</span> <span class=nx>ok</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nx>value</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
				<span class=nx>m</span><span class=p>[</span><span class=nx>two</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span><span class=o>--</span>
				<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>two</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
			<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
				<span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=nx>two</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span> <span class=c1>// прибираемся, так как ключ уже не нужен (== 0)
</span><span class=c1></span>			<span class=p>}</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>result</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v\n&#34;</span><span class=p>,</span> <span class=nf>intersection</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>23</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>6</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>23</span><span class=p>}))</span> <span class=c1>// [2, 23]
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v\n&#34;</span><span class=p>,</span> <span class=nf>intersection</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>}))</span>      <span class=c1>// [1, 1, 1]
</span><span class=c1></span><span class=p>}</span>
</code></pre></div>
</div>
</details>
<p>Сложность этого решения получается <code>O(n+m)</code> где <code>n</code> - это длина первого слайса и <code>m</code> второго (сложность вставки в мапу <code>O(1)</code>; поиска тоже, чаще всего).</p>
<p>Или вот универсальный вариант, что ищет пересечение в неограниченном количестве слайсов на входе:</p>
<details class=spoiler>
<summary>Универсальное решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>intersection</span><span class=p>(</span><span class=nx>in</span> <span class=o>...</span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>result</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>

  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>2</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>result</span>
  <span class=p>}</span>

  <span class=kd>var</span> <span class=nx>longestSliceIdx</span> <span class=p>=</span> <span class=mi>0</span>

  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// находим самый длинный слайс
</span><span class=c1></span>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>[</span><span class=nx>longestSliceIdx</span><span class=p>])</span> <span class=p>{</span>
      <span class=nx>longestSliceIdx</span> <span class=p>=</span> <span class=nx>i</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=kd>var</span> <span class=nx>m</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>uint</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1>// слайс из мап для счётчиков значений
</span><span class=c1></span>
  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// &#34;прогреваем&#34; мапы по каждому полученному слайсу
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nx>longestSliceIdx</span> <span class=p>{</span> <span class=c1>// кроме самого длинного
</span><span class=c1></span>      <span class=k>continue</span>
    <span class=p>}</span>

    <span class=nx>m</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>uint</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>k</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
      <span class=nx>m</span><span class=p>[</span><span class=nx>j</span><span class=p>][</span><span class=nx>k</span><span class=p>]</span><span class=o>++</span>
    <span class=p>}</span>

    <span class=nx>j</span><span class=o>++</span>
  <span class=p>}</span>

<span class=nx>valuesLoop</span><span class=p>:</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span><span class=p>[</span><span class=nx>longestSliceIdx</span><span class=p>]</span> <span class=p>{</span> <span class=c1>// проходимся по всем значениям из самого длинного слайса
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>mmap</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span> <span class=c1>// пробегаемся по всем мапам, что хранят количество вхождений
</span><span class=c1></span>      <span class=k>if</span> <span class=nx>count</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>mmap</span><span class=p>[</span><span class=nx>value</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span> <span class=c1>// и если в карте найдено значение из самого длинного слайса
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>count</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span> <span class=c1>// и его счётчик больше нуля
</span><span class=c1></span>          <span class=nx>mmap</span><span class=p>[</span><span class=nx>value</span><span class=p>]</span><span class=o>--</span> <span class=c1>// то уменьшаем его счётчик и НЕ прерываем цикл
</span><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// если значения есть и оно == 0
</span><span class=c1></span>          <span class=nb>delete</span><span class=p>(</span><span class=nx>mmap</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span> <span class=c1>// то удаляем его (прибираемся)
</span><span class=c1></span>
          <span class=k>continue</span> <span class=nx>valuesLoop</span> <span class=c1>// и переходим к следующему значению (не ищем во всех мапах)
</span><span class=c1></span>        <span class=p>}</span>
      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>continue</span> <span class=nx>valuesLoop</span> <span class=c1>// если значения в мапе нет, то и в других мапах искать нет смысла
</span><span class=c1></span>      <span class=p>}</span>

      <span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=nx>result</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v\n&#34;</span><span class=p>,</span> <span class=nf>intersection</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>23</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>6</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>23</span><span class=p>}))</span> <span class=c1>// [23, 2]
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v\n&#34;</span><span class=p>,</span> <span class=nf>intersection</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>}))</span>      <span class=c1>// [1, 1, 1]
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v\n&#34;</span><span class=p>,</span> <span class=nf>intersection</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>}))</span>         <span class=c1>// [2, 2]
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v\n&#34;</span><span class=p>,</span> <span class=nf>intersection</span><span class=p>([]</span><span class=kt>int</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>5</span><span class=p>},</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>9</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>4</span><span class=p>}))</span>   <span class=c1>// [9, 4]
</span><span class=c1></span><span class=p>}</span>
</code></pre></div>
</div>
</details>
<h2 id=развернуть-односвязный-список>Развернуть односвязный список</h2>
<p>Односвязный список (single linked list) может быть представлен структурой:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>LinkNode</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>next</span>  <span class=o>*</span><span class=nx>LinkNode</span>
  <span class=nx>value</span> <span class=kt>int</span>
<span class=p>}</span>
</code></pre></div><p>Нужно создать три элемента, и связать их последовательно. А после развернуть этот список в обратную сторону.</p>
<details class=spoiler>
<summary>Решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>type</span> <span class=nx>LinkNode</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>next</span>  <span class=o>*</span><span class=nx>LinkNode</span>
	<span class=nx>value</span> <span class=kt>int</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>LinkNode</span><span class=p>)</span> <span class=nf>Print</span><span class=p>()</span> <span class=p>{</span>
	<span class=c1>// ставим current указателем на первый элемент, на каждой итерации заменяя его на next
</span><span class=c1></span>	<span class=c1>// до тех пор, пока current не станет nil
</span><span class=c1></span>	<span class=k>for</span> <span class=nx>current</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>;</span> <span class=nx>current</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>current</span> <span class=p>=</span> <span class=nx>current</span><span class=p>.</span><span class=nx>next</span> <span class=p>{</span>
		<span class=nb>print</span><span class=p>(</span><span class=nx>current</span><span class=p>.</span><span class=nx>value</span><span class=p>)</span>

		<span class=k>if</span> <span class=nx>current</span><span class=p>.</span><span class=nx>next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nb>println</span><span class=p>(</span><span class=s>&#34; -&gt;&#34;</span><span class=p>,</span> <span class=nx>current</span><span class=p>.</span><span class=nx>next</span><span class=p>.</span><span class=nx>value</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=nb>println</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
	<span class=c1>// инициализируем элементы списка
</span><span class=c1></span>	<span class=kd>var</span> <span class=nx>n1</span><span class=p>,</span> <span class=nx>n2</span><span class=p>,</span> <span class=nx>n3</span> <span class=p>=</span> <span class=nx>LinkNode</span><span class=p>{</span><span class=nx>value</span><span class=p>:</span> <span class=mi>1</span><span class=p>},</span> <span class=nx>LinkNode</span><span class=p>{</span><span class=nx>value</span><span class=p>:</span> <span class=mi>2</span><span class=p>},</span> <span class=nx>LinkNode</span><span class=p>{</span><span class=nx>value</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
	<span class=nx>n1</span><span class=p>.</span><span class=nx>next</span><span class=p>,</span> <span class=nx>n2</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>n2</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>n3</span> <span class=c1>// и связываем их
</span><span class=c1></span>
	<span class=nx>n1</span><span class=p>.</span><span class=nf>Print</span><span class=p>()</span>
	<span class=c1>// 1 -&gt; 2
</span><span class=c1></span>	<span class=c1>// 2 -&gt; 3
</span><span class=c1></span>	<span class=c1>// 3
</span><span class=c1></span>
	<span class=c1>// и теперь обратим список в зад
</span><span class=c1></span>	<span class=kd>var</span> <span class=nx>prev</span><span class=p>,</span> <span class=nx>next</span> <span class=o>*</span><span class=nx>LinkNode</span>

	<span class=c1>// крутим цикл до тех пор, пока current не станет nil
</span><span class=c1></span>	<span class=k>for</span> <span class=nx>current</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>n1</span><span class=p>;</span> <span class=nx>current</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=p>{</span>
		<span class=nx>next</span><span class=p>,</span> <span class=nx>current</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>current</span><span class=p>.</span><span class=nx>next</span><span class=p>,</span> <span class=nx>prev</span>
		<span class=nx>prev</span><span class=p>,</span> <span class=nx>current</span> <span class=p>=</span> <span class=nx>current</span><span class=p>,</span> <span class=nx>next</span>
	<span class=p>}</span>

	<span class=nx>n3</span><span class=p>.</span><span class=nf>Print</span><span class=p>()</span>
	<span class=c1>// 3 -&gt; 2
</span><span class=c1></span>	<span class=c1>// 2 -&gt; 1
</span><span class=c1></span>	<span class=c1>// 1
</span><span class=c1></span><span class=p>}</span>
</code></pre></div>
</div>
</details>
<h2 id=написать-генератор-случайных-чисел>Написать генератор случайных чисел</h2>
<p>Легкая задача, на базовые знания по асинхронному взаимодействию в Go. Главная особенность - не выделять память заранее под случайные числа, так как их могут быть миллионы (в этом же и есть весть смысл генератора). Функция <code>RandomGen</code> возвращает канал, в который пишутся случайные сислы и функцию, которая генератор останавливает, освобождая все необходимые ресурсы:</p>
<details class=spoiler>
<summary>Решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;math/rand&#34;</span>
  <span class=s>&#34;sync/atomic&#34;</span>
  <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>RandomGen</span><span class=p>()</span> <span class=p>(</span><span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=kd>func</span><span class=p>())</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=p>(</span>
    <span class=nx>rnd</span>       <span class=p>=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>NewSource</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>()))</span>
    <span class=nx>out</span><span class=p>,</span> <span class=nx>exit</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=nx>exited</span>    <span class=kt>uint32</span> <span class=c1>// atomic usage only
</span><span class=c1></span>  <span class=p>)</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span> <span class=c1>// уходя гасим за собой свет (закрываем канал)
</span><span class=c1></span>
    <span class=k>for</span> <span class=p>{</span>
      <span class=k>select</span> <span class=p>{</span>
      <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>exit</span><span class=p>:</span> <span class=c1>// закрытие канала exit вызовет этот case
</span><span class=c1></span>        <span class=k>return</span>

      <span class=k>case</span> <span class=nx>out</span> <span class=o>&lt;-</span> <span class=nx>rnd</span><span class=p>.</span><span class=nf>Int</span><span class=p>():</span> <span class=c1>// пока канал exit не закрыт - отправляем
</span><span class=c1></span>        <span class=c1>// do nothing
</span><span class=c1></span>      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}()</span>

  <span class=k>return</span> <span class=nx>out</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// вызов функции закроет канал exit
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapUint32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>exited</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// защита от повторного вызова
</span><span class=c1></span>      <span class=nb>close</span><span class=p>(</span><span class=nx>exit</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>rnd</span><span class=p>,</span> <span class=nx>stop</span> <span class=o>:=</span> <span class=nf>RandomGen</span><span class=p>()</span>
  <span class=k>defer</span> <span class=nf>stop</span><span class=p>()</span> <span class=c1>// можно вызвать несколько раз - ничего страшного
</span><span class=c1></span>
  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>rnd</span><span class=p>)</span> <span class=c1>// выведет 3 случайных числа
</span><span class=c1></span>  <span class=p>}</span>

  <span class=nf>stop</span><span class=p>()</span> <span class=c1>// останавливаем генератор
</span><span class=c1></span>
  <span class=nb>println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>rnd</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>rnd</span><span class=p>)</span> <span class=c1>// вернёт дважды 0
</span><span class=c1></span><span class=p>}</span>
</code></pre></div>
</div>
</details>
<h2 id=слить-n-каналов-в-один>Слить N каналов в один</h2>
<p>Даны n каналов типа chan int. Надо написать функцию, которая смерджит все данные из этих каналов в один и вернет его. Мы хотим, чтобы результат работы функции выглядел примерно так:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>

  <span class=c1>// ...
</span><span class=c1></span>
  <span class=k>for</span> <span class=nx>num</span> <span class=o>:=</span> <span class=k>range</span> <span class=nf>joinChannels</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Для этого создаём канал для смердженных данных, запускаем N горутин для чтения из каналов (по количеству каналов), и используем дополнительный канал для того, чтоб определить когда у нас работа будет завершена (эдакий аналог <code>sync.WaitGroup</code>):</p>
<details class=spoiler>
<summary>Решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>joinChannels</span><span class=p>(</span><span class=nx>in</span> <span class=o>...&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=p>(</span>
    <span class=nx>out</span>  <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>))</span>
    <span class=nx>done</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// канал для пустых сообщений, аналог sync.WaitGroup
</span><span class=c1></span>  <span class=p>)</span>

  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// запускаем горутины по кол-ву каналов на входе
</span><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>c</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=p>}()</span> <span class=c1>// по завершению работы пишем в канал &#34;done&#34;
</span><span class=c1></span>
      <span class=k>for</span> <span class=p>{</span>
        <span class=nx>value</span><span class=p>,</span> <span class=nx>isOpened</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span>
        <span class=k>if</span> <span class=p>!</span><span class=nx>isOpened</span> <span class=p>{</span> <span class=c1>// если канал закрылся - то выходим
</span><span class=c1></span>          <span class=k>return</span>
        <span class=p>}</span>

        <span class=nx>out</span> <span class=o>&lt;-</span> <span class=nx>value</span> <span class=c1>// иначе пишем в результирующий канал
</span><span class=c1></span>      <span class=p>}</span>
    <span class=p>}(</span><span class=nx>in</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
  <span class=p>}</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// запускаем отдельную горутину, которая ожидает завершения работы
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// с помощью этого счётчика
</span><span class=c1></span>      <span class=o>&lt;-</span><span class=nx>done</span> <span class=c1>// который N раз просто читает пустую структуру и блокируется
</span><span class=c1></span>    <span class=p>}</span>

    <span class=nb>close</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
    <span class=nb>close</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
  <span class=p>}()</span>

  <span class=k>return</span> <span class=nx>out</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>num</span> <span class=o>:=</span> <span class=k>range</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span> <span class=p>{</span> <span class=nx>a</span> <span class=o>&lt;-</span> <span class=nx>num</span> <span class=p>}</span>
    <span class=nb>close</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
  <span class=p>}()</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>num</span> <span class=o>:=</span> <span class=k>range</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>20</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>30</span><span class=p>}</span> <span class=p>{</span> <span class=nx>b</span> <span class=o>&lt;-</span> <span class=nx>num</span> <span class=p>}</span>
    <span class=nb>close</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
  <span class=p>}()</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>num</span> <span class=o>:=</span> <span class=k>range</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>300</span><span class=p>,</span> <span class=mi>200</span><span class=p>,</span> <span class=mi>100</span><span class=p>}</span> <span class=p>{</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>num</span> <span class=p>}</span>
    <span class=nb>close</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
  <span class=p>}()</span>

  <span class=k>for</span> <span class=nx>num</span> <span class=o>:=</span> <span class=k>range</span> <span class=nf>joinChannels</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span> <span class=c1>// 1, 2, 3, 20, 10, 300, 200, 30, 100
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div>
</div>
</details>
<h2 id=сделать-конвейер-чисел>Сделать конвейер чисел</h2>
<p>Даны два канала. В первый пишутся числа. Нужно, чтобы числа читались из первого по мере поступления, что-то с ними происходило (допустим, возводились в квадрат) и результат записывался во второй канал. Задача <strong>пердельно</strong> простая.</p>
<details class=spoiler>
<summary>Решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>in</span><span class=p>,</span> <span class=nx>out</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
      <span class=nx>in</span> <span class=o>&lt;-</span> <span class=nx>i</span>
    <span class=p>}</span>

    <span class=nb>close</span><span class=p>(</span><span class=nx>in</span><span class=p>)</span>
  <span class=p>}()</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>

    <span class=k>for</span> <span class=p>{</span>
      <span class=nx>num</span><span class=p>,</span> <span class=nx>isOpened</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>in</span>
      <span class=k>if</span> <span class=p>!</span><span class=nx>isOpened</span> <span class=p>{</span>
        <span class=k>return</span>
      <span class=p>}</span>

      <span class=nx>out</span> <span class=o>&lt;-</span> <span class=nx>num</span> <span class=o>*</span> <span class=nx>num</span>
    <span class=p>}</span>
  <span class=p>}()</span>

  <span class=k>for</span> <span class=nx>num</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>out</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div>
</div>
</details>
<h2 id=сделать-кастомную-waitgroup-на-семафоре>Сделать кастомную WaitGroup на семафоре</h2>
<blockquote>
<p>Семафо́р (англ. <code>semaphore</code>) — примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: увеличение и уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся.</p>
</blockquote>
<p>Семафор можно легко получить из канала. Чтоб не аллоцировать лишние данные, будем складывать туда пустые структуры.</p>
<details class=spoiler>
<summary>Решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>type</span> <span class=nx>Semaphore</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>Semaphore</span><span class=p>)</span> <span class=nf>Increment</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>s</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=nx>Semaphore</span><span class=p>)</span> <span class=nf>Decrement</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=o>&lt;-</span><span class=nx>s</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
	<span class=kd>const</span> <span class=nx>count</span> <span class=p>=</span> <span class=mi>5</span>

	<span class=kd>var</span> <span class=nx>s</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Semaphore</span><span class=p>,</span> <span class=nx>count</span><span class=p>)</span>

	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>count</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>defer</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Increment</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>

			<span class=nb>print</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>)</span>
		<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>s</span><span class=p>.</span><span class=nf>Decrement</span><span class=p>(</span><span class=nx>count</span><span class=p>)</span> <span class=c1>// 1 4 3 2 0 (порядок будет произвольный)
</span><span class=c1></span><span class=p>}</span>
</code></pre></div>
</div>
</details>
<details class=spoiler>
<summary>Решение с использованием atomic и каналов, полностью повторяет API sync.WaitGroup</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;sync&#34;</span>
  <span class=s>&#34;sync/atomic&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>WaitGroup</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>state</span> <span class=kt>int32</span> <span class=c1>// atomic usage only
</span><span class=c1></span>
  <span class=nx>subsMu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
  <span class=nx>subs</span>   <span class=p>[]</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>NewWaitGroup</span><span class=p>()</span> <span class=nx>WaitGroup</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>WaitGroup</span><span class=p>{</span><span class=nx>subs</span><span class=p>:</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>0</span><span class=p>)}</span> <span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>wg</span> <span class=o>*</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>n</span> <span class=kt>uint</span><span class=p>)</span> <span class=p>{</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>wg</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>n</span><span class=p>))</span> <span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>wg</span> <span class=o>*</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=nf>Done</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>wg</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>wg</span><span class=p>.</span><span class=nx>state</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nx>subsMu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>

    <span class=k>if</span> <span class=nx>wg</span><span class=p>.</span><span class=nx>subs</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
      <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>wg</span><span class=p>.</span><span class=nx>subs</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nb>close</span><span class=p>(</span><span class=nx>wg</span><span class=p>.</span><span class=nx>subs</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span> <span class=c1>// закрытие &#34;стриггерит&#34; все каналы
</span><span class=c1></span>      <span class=p>}</span>

      <span class=nx>wg</span><span class=p>.</span><span class=nx>subs</span> <span class=p>=</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=nx>wg</span><span class=p>.</span><span class=nx>subsMu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>wg</span> <span class=o>*</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=nf>Wait</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>wg</span><span class=p>.</span><span class=nx>state</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>c</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>

    <span class=nx>wg</span><span class=p>.</span><span class=nx>subsMu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nx>subs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>wg</span><span class=p>.</span><span class=nx>subs</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nx>subsMu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>

    <span class=o>&lt;-</span><span class=nx>c</span> <span class=c1>// ожидаем закрытия канала (блокируемся)
</span><span class=c1></span>  <span class=p>}</span>

  <span class=k>return</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>wg</span> <span class=p>=</span> <span class=nf>NewWaitGroup</span><span class=p>()</span>

  <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span> <span class=c1>// пролетает сразу же, так как не было вызовов Add()
</span><span class=c1></span>
  <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
  <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1>// ничего не делает
</span><span class=c1></span>  <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
  <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
  <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span> <span class=c1>// тоже пролетает сразу же
</span><span class=c1></span>
  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>

    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>

      <span class=nb>print</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>)</span>
    <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
  <span class=p>}</span>

  <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span> <span class=c1>// 1 4 3 2 0 (порядок будет произвольный)
</span><span class=c1></span><span class=p>}</span>
</code></pre></div>
</div>
</details>
<h2 id=алгоритм-бинарного-двоичного-поиска>Алгоритм бинарного (двоичного) поиска</h2>
<p>Также известен как метод деления пополам или дихотомия - классический алгоритм поиска элемента в отсортированном массиве (слайсе), использующий дробление массива (слайса) на половины. У нас на входе может быть слайс вида <code>[]int{1, 3, 4, 6, 8, 10, 55, 56, 59, 70, 79, 81, 91, 10001}</code>, и нужно вернуть индекс числа <code>55</code> (результат будет <code>6 true</code>):</p>
<details class=spoiler>
<summary>Решение</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>BinarySearch</span><span class=p>(</span><span class=nx>in</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>searchFor</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>false</span>
	<span class=p>}</span>

	<span class=kd>var</span> <span class=nx>first</span><span class=p>,</span> <span class=nx>last</span> <span class=p>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>in</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>

	<span class=k>for</span> <span class=nx>first</span> <span class=o>&lt;=</span> <span class=nx>last</span> <span class=p>{</span>
		<span class=kd>var</span> <span class=nx>mid</span> <span class=p>=</span> <span class=p>((</span><span class=nx>last</span> <span class=o>-</span> <span class=nx>first</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=nx>first</span>

		<span class=k>if</span> <span class=nx>in</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=o>==</span> <span class=nx>searchFor</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>mid</span><span class=p>,</span> <span class=kc>true</span>
		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>in</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>searchFor</span> <span class=p>{</span> <span class=c1>// нужно искать в &#34;левой&#34; части слайса
</span><span class=c1></span>			<span class=nx>last</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>-</span> <span class=mi>1</span>
		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>in</span><span class=p>[</span><span class=nx>mid</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>searchFor</span> <span class=p>{</span> <span class=c1>// нужно искать в &#34;правой&#34; части слайса
</span><span class=c1></span>			<span class=nx>first</span> <span class=p>=</span> <span class=nx>mid</span> <span class=o>+</span> <span class=mi>1</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>false</span>
<span class=p>}</span>
</code></pre></div>
</div>
</details>
<h2 id=обход-ссылок-из-файла>Обход ссылок из файла</h2>
<p>Дан некоторый файл, в котором содержатся HTTP ссылки на различные ресурсы. Нужно реализовать обход всех этих ссылок, и вывести в терминал <code>OK</code> в случае <code>200</code>-го кода ответа, и <code>Not OK</code> в противном случае. Засучаем рукава и в бой, пишем наивный вариант (читаем файл в память, и итерируем слайс ссылок):</p>
<details class=spoiler>
<summary>Первая итерация</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;bufio&#34;</span>
  <span class=s>&#34;context&#34;</span>
  <span class=s>&#34;net/http&#34;</span>
  <span class=s>&#34;os&#34;</span>
  <span class=s>&#34;strings&#34;</span>
  <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>

    <span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>run</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>

  <span class=c1>// открываем файл
</span><span class=c1></span>  <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=s>&#34;links_list.txt&#34;</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span> <span class=p>}()</span>

  <span class=c1>// читаем файл построчно
</span><span class=c1></span>  <span class=kd>var</span> <span class=nx>scan</span> <span class=p>=</span> <span class=nx>bufio</span><span class=p>.</span><span class=nf>NewScanner</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
  <span class=k>for</span> <span class=nx>scan</span><span class=p>.</span><span class=nf>Scan</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>url</span> <span class=p>=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>scan</span><span class=p>.</span><span class=nf>Text</span><span class=p>())</span>

    <span class=k>if</span> <span class=nx>ok</span><span class=p>,</span> <span class=nx>fetchErr</span> <span class=o>:=</span> <span class=nf>fetchLink</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>MethodGet</span><span class=p>,</span> <span class=nx>url</span><span class=p>);</span> <span class=nx>fetchErr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
      <span class=k>return</span> <span class=nx>fetchErr</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;OK&#34;</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;Not OK&#34;</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c1>// проверяем сканер на наличие ошибок
</span><span class=c1></span>  <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>scan</span><span class=p>.</span><span class=nf>Err</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>err</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// объявляем HTTP клиент для переиспользования
</span><span class=c1></span><span class=kd>var</span> <span class=nx>httpClient</span> <span class=p>=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span><span class=nx>Timeout</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>5</span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>fetchLink</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>url</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// создаём объект запроса
</span><span class=c1></span>  <span class=kd>var</span> <span class=nx>req</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewRequestWithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>url</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>NoBody</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>

  <span class=c1>// выполняем его
</span><span class=c1></span>  <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>httpClient</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>

  <span class=c1>// валидируем статус код
</span><span class=c1></span>  <span class=k>if</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>StatusCode</span> <span class=o>==</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>nil</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div>
</div>
</details>
<p>Файл со списком ссылок (<code>links_list.txt</code>):</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text>https://www.yahoo.com/foobar
https://stackoverflow.com/foobar
https://blog.iddqd.uk/
https://google.com/404error
https://ya.ru/
https://github.com/foo/bar
https://stackoverflow.com/
</code></pre></div><p>Запускаем код (<code>go run .</code>), видим результат:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text>Not OK https://www.yahoo.com/foobar
Not OK https://stackoverflow.com/foobar
OK https://blog.iddqd.uk/
Not OK https://google.com/404error
OK https://ya.ru/
Not OK https://github.com/foo/bar
OK https://stackoverflow.com/
</code></pre></div><p>И тут интервьювер обновляет постановку задачи - нужно выполнять работу асинхронно. И сделать так, чтоб после получения <strong>двух</strong> <code>OK</code> останавливать всю работу, отменяя уже отправленные запросы. Приводим свой код в соответствие, используя каналы по-максимуму:</p>
<details class=spoiler>
<summary>Вторая итерация</summary>
<div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;bufio&#34;</span>
  <span class=s>&#34;context&#34;</span>
  <span class=s>&#34;errors&#34;</span>
  <span class=s>&#34;net/http&#34;</span>
  <span class=s>&#34;os&#34;</span>
  <span class=s>&#34;strings&#34;</span>
  <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>run</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;Fatal error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>

    <span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>result</span> <span class=kd>struct</span> <span class=p>{</span> <span class=c1>// объявляем структуру для описания результата опроса URL
</span><span class=c1></span>  <span class=nx>url</span> <span class=kt>string</span>
  <span class=nx>ok</span>  <span class=kt>bool</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>run</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>())</span> <span class=c1>// заменяем контекст на контекст с отменой
</span><span class=c1></span>  <span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>

  <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=s>&#34;links_list.txt&#34;</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span> <span class=p>}()</span>

  <span class=kd>var</span> <span class=nx>urlsCh</span><span class=p>,</span> <span class=nx>errCh</span><span class=p>,</span> <span class=nx>resultsCh</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>error</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>result</span><span class=p>)</span> <span class=c1>// объявляем каналы для работы
</span><span class=c1></span>  <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nb>close</span><span class=p>(</span><span class=nx>errCh</span><span class=p>);</span> <span class=nb>close</span><span class=p>(</span><span class=nx>resultsCh</span><span class=p>)</span> <span class=p>}()</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// читаем файл построчно в отдельной горутине и пишем в каналы (запускаем &#34;планировщик&#34;)
</span><span class=c1></span>    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>urlsCh</span><span class=p>)</span> <span class=c1>// не забываем закрыть канал (когда список кончится или контекст отменится)
</span><span class=c1></span>
    <span class=kd>var</span> <span class=nx>scan</span> <span class=p>=</span> <span class=nx>bufio</span><span class=p>.</span><span class=nf>NewScanner</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>scan</span><span class=p>.</span><span class=nf>Scan</span><span class=p>()</span> <span class=p>{</span>
      <span class=k>select</span> <span class=p>{</span>
      <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span> <span class=c1>// проверяем контекст на факт его отмены
</span><span class=c1></span>        <span class=k>return</span>

      <span class=k>default</span><span class=p>:</span>
        <span class=k>if</span> <span class=nx>url</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>scan</span><span class=p>.</span><span class=nf>Text</span><span class=p>());</span> <span class=nx>url</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
          <span class=nx>urlsCh</span> <span class=o>&lt;-</span> <span class=nx>url</span> <span class=c1>// и пишем в канал для ссылок по одной
</span><span class=c1></span>        <span class=p>}</span>
      <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>scan</span><span class=p>.</span><span class=nf>Err</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
      <span class=nx>errCh</span> <span class=o>&lt;-</span> <span class=nx>err</span>
    <span class=p>}</span>
  <span class=p>}()</span>

  <span class=kd>const</span> <span class=nx>workersCount</span> <span class=kt>uint8</span> <span class=p>=</span> <span class=mi>4</span> <span class=c1>// объявляем константу с количеством &#34;воркеров&#34;
</span><span class=c1></span>
  <span class=kd>var</span> <span class=nx>progress</span><span class=p>,</span> <span class=nx>done</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// каналы для сообщений о ходе работы и её завершении
</span><span class=c1></span>  <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>

  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// запускаем горутину, что будет N раз ничего не делать, а по завершении запишет в канал done
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>workersCount</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
      <span class=o>&lt;-</span><span class=nx>progress</span>
    <span class=p>}</span>

    <span class=nb>close</span><span class=p>(</span><span class=nx>progress</span><span class=p>)</span>

    <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
  <span class=p>}()</span>

  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>workersCount</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// запускаем горутины для выполнения HTTP запросов
</span><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
      <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>progress</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=p>}()</span> <span class=c1>// когда она завершится, то запишет в канал progress
</span><span class=c1></span>
      <span class=k>for</span> <span class=p>{</span>
        <span class=k>select</span> <span class=p>{</span>
        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span> <span class=c1>// так же проверяем контекст на факт его отмены
</span><span class=c1></span>          <span class=k>return</span>

        <span class=k>case</span> <span class=nx>url</span><span class=p>,</span> <span class=nx>isOpened</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>urlsCh</span><span class=p>:</span> <span class=c1>// и читаем из канала для ссылок
</span><span class=c1></span>          <span class=k>if</span> <span class=p>!</span><span class=nx>isOpened</span> <span class=p>{</span> <span class=c1>// если он закрыт нашим &#34;планировщиком&#34;
</span><span class=c1></span>            <span class=k>return</span> <span class=c1>// то выходим
</span><span class=c1></span>          <span class=p>}</span>

          <span class=k>if</span> <span class=nx>ok</span><span class=p>,</span> <span class=nx>fetchErr</span> <span class=o>:=</span> <span class=nf>fetchLink</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>MethodGet</span><span class=p>,</span> <span class=nx>url</span><span class=p>);</span> <span class=nx>fetchErr</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>errCh</span> <span class=o>&lt;-</span> <span class=nx>fetchErr</span>
          <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span> <span class=c1>// дополнительно проверяем контекст
</span><span class=c1></span>            <span class=nx>resultsCh</span> <span class=o>&lt;-</span> <span class=nx>result</span><span class=p>{</span><span class=nx>url</span><span class=p>:</span> <span class=nx>url</span><span class=p>,</span> <span class=nx>ok</span><span class=p>:</span> <span class=nx>ok</span><span class=p>}</span> <span class=c1>// результаты пишем в канал для ответов
</span><span class=c1></span>          <span class=p>}</span>
        <span class=p>}</span>
      <span class=p>}</span>
    <span class=p>}()</span>
  <span class=p>}</span>

  <span class=kd>var</span> <span class=p>(</span>
    <span class=nx>okCounter</span> <span class=kt>uint</span>  <span class=c1>// счётчик успешных запросов
</span><span class=c1></span>    <span class=nx>lastError</span> <span class=kt>error</span> <span class=c1>// переменная для последней &#34;пойманной&#34; ошибки
</span><span class=c1></span>  <span class=p>)</span>

<span class=nx>loop</span><span class=p>:</span>
  <span class=k>for</span> <span class=p>{</span>
    <span class=k>select</span> <span class=p>{</span>
    <span class=k>case</span> <span class=nx>workingErr</span><span class=p>,</span> <span class=nx>isOpened</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>errCh</span><span class=p>:</span> <span class=c1>// если пришла ошибка (при чтении файла или HTTP)
</span><span class=c1></span>      <span class=k>if</span> <span class=nx>isOpened</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>errors</span><span class=p>.</span><span class=nf>Is</span><span class=p>(</span><span class=nx>workingErr</span><span class=p>,</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Canceled</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// игнорируем ошибку &#34;отмены контекста&#34;
</span><span class=c1></span>        <span class=nx>lastError</span> <span class=p>=</span> <span class=nx>workingErr</span> <span class=c1>// то сохраняем её в lastError
</span><span class=c1></span>        <span class=nf>cancel</span><span class=p>()</span>               <span class=c1>// и отменяем контекст (чтоб горутины завершились) но не прерываем цикл
</span><span class=c1></span>      <span class=p>}</span>

    <span class=k>case</span> <span class=nx>res</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>resultsCh</span><span class=p>:</span> <span class=c1>// если пришел результат от воркера
</span><span class=c1></span>      <span class=k>if</span> <span class=nx>res</span><span class=p>.</span><span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>okCounter</span><span class=o>++</span>
        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;OK&#34;</span><span class=p>,</span> <span class=nx>res</span><span class=p>.</span><span class=nx>url</span><span class=p>)</span>
      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nb>println</span><span class=p>(</span><span class=s>&#34;Not OK&#34;</span><span class=p>,</span> <span class=nx>res</span><span class=p>.</span><span class=nx>url</span><span class=p>)</span>
      <span class=p>}</span>

      <span class=k>if</span> <span class=nx>okCounter</span> <span class=o>&gt;=</span> <span class=mi>2</span> <span class=p>{</span> <span class=c1>// а вот как раз и наше условие для отмены
</span><span class=c1></span>        <span class=nf>cancel</span><span class=p>()</span>
      <span class=p>}</span>

    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>done</span><span class=p>:</span> <span class=c1>// и выход из цикла обязательно должен осуществится после сообщения в done
</span><span class=c1></span>      <span class=nb>println</span><span class=p>(</span><span class=s>&#34;work is done&#34;</span><span class=p>)</span>

      <span class=k>break</span> <span class=nx>loop</span> <span class=c1>// только тут прерываем цикл, так как горутины все вышли и никто не напишет в закрытые каналы
</span><span class=c1></span>    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=nx>lastError</span>
<span class=p>}</span>

<span class=c1>// объявляем HTTP клиент для переиспользования
</span><span class=c1></span><span class=kd>var</span> <span class=nx>httpClient</span> <span class=p>=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span><span class=nx>Timeout</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>5</span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>fetchLink</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>url</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// создаём объект запроса
</span><span class=c1></span>  <span class=kd>var</span> <span class=nx>req</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewRequestWithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>url</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>NoBody</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>

  <span class=c1>// выполняем его
</span><span class=c1></span>  <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>httpClient</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>

  <span class=c1>// валидируем статус код
</span><span class=c1></span>  <span class=k>if</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>StatusCode</span> <span class=o>==</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>nil</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div>
</div>
</details>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/go/>go</a>
<a href=/tags/coding/>coding</a>
</section>
<div style=display:flex;justify-content:space-between;margin-top:1em>
<div>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>WTFPL</span>
</section>
</div>
<div style=margin-left:auto><section style=height:100%>
<a href=https://github.com/iddqd-uk/blog/edit/master/content/post/interview-section-golang-coding/index.md style=font-size:.7em;color:var(--card-text-color-tertiary)>Редиктировать</a>
</section>
</div>
</div></footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Может быть интересно</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/interview-section-golang/>
<div class=article-image>
<img src=/interview-section-golang/cover.f4a8a0debf71679bfd758da95e284bcb_hu032bd5f7e68e559a642ecef405e28712_26494_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post Вопросы и ответы для собеседования Go-разработчика" data-key=interview-section-golang data-hash="md5-9Kig3r9xZ5v9dY2pXihLyw==">
</div>
<div class=article-details>
<h2 class=article-title>Вопросы и ответы для собеседования Go-разработчика</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/yandex-interview-questions/>
<div class=article-image>
<img src=/yandex-interview-questions/cover.091604f6242b958abb20698472bc1427_hu189ac99d92bfe66fb9120bb88310aa74_36894_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post Yandex Interview Questions" data-key=yandex-interview-questions data-hash="md5-CRYE9iQrlYq7IGmEcrwUJw==">
</div>
<div class=article-details>
<h2 class=article-title>Yandex Interview Questions</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/interview-section-network/>
<div class=article-image>
<img src=/interview-section-network/cover.c258292f544432328883fabf607bf92b_hu21de3eef183cf18e204d3e54b899aa35_31715_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post Вопросы и ответы по сетям и протоколам" data-key=interview-section-network data-hash="md5-wlgpL1REMjKIg/q/YHv5Kw==">
</div>
<div class=article-details>
<h2 class=article-title>Вопросы и ответы по сетям и протоколам</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<script src=https://utteranc.es/client.js repo=iddqd-uk/blog issue-term=pathname crossorigin=anonymous async></script>
<style>.utterances{max-width:unset}</style>
<script>function setUtterancesTheme(b){let a=document.querySelector('.utterances iframe');a&&a.contentWindow.postMessage({type:'set-theme',theme:`github-${b}`},'https://utteranc.es')}addEventListener('message',a=>{if(a.origin!=='https://utteranc.es')return;setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener('onColorSchemeChange',a=>{setUtterancesTheme(a.detail)})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2014 -
2025 blog [dot] iddqd
</section>
<section class=powerby>
Make love, not war <br>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Содержание</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#найти-пересечение-двух-неупорядоченных-слайсов-любой-длины>Найти пересечение двух неупорядоченных слайсов любой длины</a></li>
<li><a href=#развернуть-односвязный-список>Развернуть односвязный список</a></li>
<li><a href=#написать-генератор-случайных-чисел>Написать генератор случайных чисел</a></li>
<li><a href=#слить-n-каналов-в-один>Слить N каналов в один</a></li>
<li><a href=#сделать-конвейер-чисел>Сделать конвейер чисел</a></li>
<li><a href=#сделать-кастомную-waitgroup-на-семафоре>Сделать кастомную WaitGroup на семафоре</a></li>
<li><a href=#алгоритм-бинарного-двоичного-поиска>Алгоритм бинарного (двоичного) поиска</a></li>
<li><a href=#обход-ссылок-из-файла>Обход ссылок из файла</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
<script data-no-instant>(function(){const a=document.querySelectorAll('.outdated-post'),b=new Date;for(let c=0,f=a.length;c<f;c++){const d=a[c],e=new Date(d.getAttribute('data-posted-at'));if(!isNaN(e.valueOf())&&e.getFullYear()>1){const a=Math.abs(b.getTime()-e.getTime()),c=Math.ceil(a/(1e3*3600*24));c>=547&&(d.style.display='block',d.style.visibility='visible')}}})()</script>
</body>
</html>